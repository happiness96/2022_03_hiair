// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'insepct_mode.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$InspectModeTearOff {
  const _$InspectModeTearOff();

  _None none() {
    return const _None();
  }

  _Performance performance() {
    return const _Performance();
  }

  _Paint paint() {
    return const _Paint();
  }

  _Motor motor() {
    return const _Motor();
  }

  _Photo photo() {
    return const _Photo();
  }
}

/// @nodoc
const $InspectMode = _$InspectModeTearOff();

/// @nodoc
mixin _$InspectMode {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() performance,
    required TResult Function() paint,
    required TResult Function() motor,
    required TResult Function() photo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Performance value) performance,
    required TResult Function(_Paint value) paint,
    required TResult Function(_Motor value) motor,
    required TResult Function(_Photo value) photo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InspectModeCopyWith<$Res> {
  factory $InspectModeCopyWith(
          InspectMode value, $Res Function(InspectMode) then) =
      _$InspectModeCopyWithImpl<$Res>;
}

/// @nodoc
class _$InspectModeCopyWithImpl<$Res> implements $InspectModeCopyWith<$Res> {
  _$InspectModeCopyWithImpl(this._value, this._then);

  final InspectMode _value;
  // ignore: unused_field
  final $Res Function(InspectMode) _then;
}

/// @nodoc
abstract class _$NoneCopyWith<$Res> {
  factory _$NoneCopyWith(_None value, $Res Function(_None) then) =
      __$NoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$NoneCopyWithImpl<$Res> extends _$InspectModeCopyWithImpl<$Res>
    implements _$NoneCopyWith<$Res> {
  __$NoneCopyWithImpl(_None _value, $Res Function(_None) _then)
      : super(_value, (v) => _then(v as _None));

  @override
  _None get _value => super._value as _None;
}

/// @nodoc

class _$_None extends _None {
  const _$_None() : super._();

  @override
  String toString() {
    return 'InspectMode.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _None);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() performance,
    required TResult Function() paint,
    required TResult Function() motor,
    required TResult Function() photo,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Performance value) performance,
    required TResult Function(_Paint value) paint,
    required TResult Function(_Motor value) motor,
    required TResult Function(_Photo value) photo,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _None extends InspectMode {
  const factory _None() = _$_None;
  const _None._() : super._();
}

/// @nodoc
abstract class _$PerformanceCopyWith<$Res> {
  factory _$PerformanceCopyWith(
          _Performance value, $Res Function(_Performance) then) =
      __$PerformanceCopyWithImpl<$Res>;
}

/// @nodoc
class __$PerformanceCopyWithImpl<$Res> extends _$InspectModeCopyWithImpl<$Res>
    implements _$PerformanceCopyWith<$Res> {
  __$PerformanceCopyWithImpl(
      _Performance _value, $Res Function(_Performance) _then)
      : super(_value, (v) => _then(v as _Performance));

  @override
  _Performance get _value => super._value as _Performance;
}

/// @nodoc

class _$_Performance extends _Performance {
  const _$_Performance() : super._();

  @override
  String toString() {
    return 'InspectMode.performance()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Performance);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() performance,
    required TResult Function() paint,
    required TResult Function() motor,
    required TResult Function() photo,
  }) {
    return performance();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
  }) {
    return performance?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
    required TResult orElse(),
  }) {
    if (performance != null) {
      return performance();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Performance value) performance,
    required TResult Function(_Paint value) paint,
    required TResult Function(_Motor value) motor,
    required TResult Function(_Photo value) photo,
  }) {
    return performance(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
  }) {
    return performance?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
    required TResult orElse(),
  }) {
    if (performance != null) {
      return performance(this);
    }
    return orElse();
  }
}

abstract class _Performance extends InspectMode {
  const factory _Performance() = _$_Performance;
  const _Performance._() : super._();
}

/// @nodoc
abstract class _$PaintCopyWith<$Res> {
  factory _$PaintCopyWith(_Paint value, $Res Function(_Paint) then) =
      __$PaintCopyWithImpl<$Res>;
}

/// @nodoc
class __$PaintCopyWithImpl<$Res> extends _$InspectModeCopyWithImpl<$Res>
    implements _$PaintCopyWith<$Res> {
  __$PaintCopyWithImpl(_Paint _value, $Res Function(_Paint) _then)
      : super(_value, (v) => _then(v as _Paint));

  @override
  _Paint get _value => super._value as _Paint;
}

/// @nodoc

class _$_Paint extends _Paint {
  const _$_Paint() : super._();

  @override
  String toString() {
    return 'InspectMode.paint()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Paint);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() performance,
    required TResult Function() paint,
    required TResult Function() motor,
    required TResult Function() photo,
  }) {
    return paint();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
  }) {
    return paint?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
    required TResult orElse(),
  }) {
    if (paint != null) {
      return paint();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Performance value) performance,
    required TResult Function(_Paint value) paint,
    required TResult Function(_Motor value) motor,
    required TResult Function(_Photo value) photo,
  }) {
    return paint(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
  }) {
    return paint?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
    required TResult orElse(),
  }) {
    if (paint != null) {
      return paint(this);
    }
    return orElse();
  }
}

abstract class _Paint extends InspectMode {
  const factory _Paint() = _$_Paint;
  const _Paint._() : super._();
}

/// @nodoc
abstract class _$MotorCopyWith<$Res> {
  factory _$MotorCopyWith(_Motor value, $Res Function(_Motor) then) =
      __$MotorCopyWithImpl<$Res>;
}

/// @nodoc
class __$MotorCopyWithImpl<$Res> extends _$InspectModeCopyWithImpl<$Res>
    implements _$MotorCopyWith<$Res> {
  __$MotorCopyWithImpl(_Motor _value, $Res Function(_Motor) _then)
      : super(_value, (v) => _then(v as _Motor));

  @override
  _Motor get _value => super._value as _Motor;
}

/// @nodoc

class _$_Motor extends _Motor {
  const _$_Motor() : super._();

  @override
  String toString() {
    return 'InspectMode.motor()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Motor);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() performance,
    required TResult Function() paint,
    required TResult Function() motor,
    required TResult Function() photo,
  }) {
    return motor();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
  }) {
    return motor?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
    required TResult orElse(),
  }) {
    if (motor != null) {
      return motor();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Performance value) performance,
    required TResult Function(_Paint value) paint,
    required TResult Function(_Motor value) motor,
    required TResult Function(_Photo value) photo,
  }) {
    return motor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
  }) {
    return motor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
    required TResult orElse(),
  }) {
    if (motor != null) {
      return motor(this);
    }
    return orElse();
  }
}

abstract class _Motor extends InspectMode {
  const factory _Motor() = _$_Motor;
  const _Motor._() : super._();
}

/// @nodoc
abstract class _$PhotoCopyWith<$Res> {
  factory _$PhotoCopyWith(_Photo value, $Res Function(_Photo) then) =
      __$PhotoCopyWithImpl<$Res>;
}

/// @nodoc
class __$PhotoCopyWithImpl<$Res> extends _$InspectModeCopyWithImpl<$Res>
    implements _$PhotoCopyWith<$Res> {
  __$PhotoCopyWithImpl(_Photo _value, $Res Function(_Photo) _then)
      : super(_value, (v) => _then(v as _Photo));

  @override
  _Photo get _value => super._value as _Photo;
}

/// @nodoc

class _$_Photo extends _Photo {
  const _$_Photo() : super._();

  @override
  String toString() {
    return 'InspectMode.photo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Photo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() performance,
    required TResult Function() paint,
    required TResult Function() motor,
    required TResult Function() photo,
  }) {
    return photo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
  }) {
    return photo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? performance,
    TResult Function()? paint,
    TResult Function()? motor,
    TResult Function()? photo,
    required TResult orElse(),
  }) {
    if (photo != null) {
      return photo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Performance value) performance,
    required TResult Function(_Paint value) paint,
    required TResult Function(_Motor value) motor,
    required TResult Function(_Photo value) photo,
  }) {
    return photo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
  }) {
    return photo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Performance value)? performance,
    TResult Function(_Paint value)? paint,
    TResult Function(_Motor value)? motor,
    TResult Function(_Photo value)? photo,
    required TResult orElse(),
  }) {
    if (photo != null) {
      return photo(this);
    }
    return orElse();
  }
}

abstract class _Photo extends InspectMode {
  const factory _Photo() = _$_Photo;
  const _Photo._() : super._();
}
